{-# LANGUAGE GADTs, KindSignatures, DataKinds #-}
{-# LANGUAGE EmptyCase #-}

module Pi.Abs (Tree(..), Expr, Ident, johnMajorEq, module Pi.ComposOp) where

import Prelude (Char, Double, Integer, String, (.), (>), (&&), (==))
import qualified Prelude as P
import qualified Data.Monoid as P

import Pi.ComposOp

-- Haskell module generated by the BNF converter

data Tag = Expr_ | Ident_
type Expr = Tree Expr_
type Ident = Tree Ident_

data Tree :: Tag -> * where
    E_Var :: Ident -> Tree Expr_
    E_Abs :: Ident -> Expr -> Tree Expr_
    E_App :: Expr -> Expr -> Tree Expr_
    E_Pi :: Ident -> Expr -> Expr -> Tree Expr_
    E_Type :: Tree Expr_
    E_Anno :: Expr -> Expr -> Tree Expr_
    Ident :: String -> Tree Ident_

instance Compos Tree where
  compos r a f t = case t of
      E_Var ident -> r E_Var `a` f ident
      E_Abs ident expr -> r E_Abs `a` f ident `a` f expr
      E_App expr0 expr1 -> r E_App `a` f expr0 `a` f expr1
      E_Pi ident expr0 expr1 -> r E_Pi `a` f ident `a` f expr0 `a` f expr1
      E_Anno expr0 expr1 -> r E_Anno `a` f expr0 `a` f expr1
      _ -> r t

instance P.Show (Tree c) where
  showsPrec n t = case t of
    E_Var ident -> opar n . P.showString "E_Var" . P.showChar ' ' . P.showsPrec 1 ident . cpar n
    E_Abs ident expr -> opar n . P.showString "E_Abs" . P.showChar ' ' . P.showsPrec 1 ident . P.showChar ' ' . P.showsPrec 1 expr . cpar n
    E_App expr0 expr1 -> opar n . P.showString "E_App" . P.showChar ' ' . P.showsPrec 1 expr0 . P.showChar ' ' . P.showsPrec 1 expr1 . cpar n
    E_Pi ident expr0 expr1 -> opar n . P.showString "E_Pi" . P.showChar ' ' . P.showsPrec 1 ident . P.showChar ' ' . P.showsPrec 1 expr0 . P.showChar ' ' . P.showsPrec 1 expr1 . cpar n
    E_Type -> P.showString "E_Type"
    E_Anno expr0 expr1 -> opar n . P.showString "E_Anno" . P.showChar ' ' . P.showsPrec 1 expr0 . P.showChar ' ' . P.showsPrec 1 expr1 . cpar n
    Ident str -> opar n . P.showString "Ident" . P.showChar ' ' . P.showsPrec 1 str . cpar n
   where opar n = if n > 0 then P.showChar '(' else P.id
         cpar n = if n > 0 then P.showChar ')' else P.id

instance P.Eq (Tree c) where (==) = johnMajorEq

johnMajorEq :: Tree a -> Tree b -> P.Bool
johnMajorEq (E_Var ident) (E_Var ident_) = ident == ident_
johnMajorEq (E_Abs ident expr) (E_Abs ident_ expr_) = ident == ident_ && expr == expr_
johnMajorEq (E_App expr0 expr1) (E_App expr0_ expr1_) = expr0 == expr0_ && expr1 == expr1_
johnMajorEq (E_Pi ident expr0 expr1) (E_Pi ident_ expr0_ expr1_) = ident == ident_ && expr0 == expr0_ && expr1 == expr1_
johnMajorEq E_Type E_Type = P.True
johnMajorEq (E_Anno expr0 expr1) (E_Anno expr0_ expr1_) = expr0 == expr0_ && expr1 == expr1_
johnMajorEq (Ident str) (Ident str_) = str == str_
johnMajorEq _ _ = P.False

instance P.Ord (Tree c) where
  compare x y = P.compare (index x) (index y) `P.mappend` compareSame x y

index :: Tree c -> P.Int
index (E_Var _) = 0
index (E_Abs _ _) = 1
index (E_App _ _) = 2
index (E_Pi _ _ _) = 3
index (E_Type ) = 4
index (E_Anno _ _) = 5
index (Ident _) = 6

compareSame :: Tree c -> Tree c -> P.Ordering
compareSame (E_Var ident) (E_Var ident_) = P.compare ident ident_
compareSame (E_Abs ident expr) (E_Abs ident_ expr_) = P.mappend (P.compare ident ident_) (P.compare expr expr_)
compareSame (E_App expr0 expr1) (E_App expr0_ expr1_) = P.mappend (P.compare expr0 expr0_) (P.compare expr1 expr1_)
compareSame (E_Pi ident expr0 expr1) (E_Pi ident_ expr0_ expr1_) = P.mappend (P.compare ident ident_) (P.mappend (P.compare expr0 expr0_) (P.compare expr1 expr1_))
compareSame E_Type E_Type = P.EQ
compareSame (E_Anno expr0 expr1) (E_Anno expr0_ expr1_) = P.mappend (P.compare expr0 expr0_) (P.compare expr1 expr1_)
compareSame (Ident str) (Ident str_) = P.compare str str_
compareSame x y = P.error "BNFC error:" compareSame

